(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{194:function(e,t,a){"use strict";a.d(t,"a",(function(){return m}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=r.a.createContext({}),l=function(e){var t=r.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(a),m=n,d=u["".concat(i,".").concat(m)]||u[m]||h[m]||o;return a?r.a.createElement(d,s(s({ref:t},p),{},{components:a})):r.a.createElement(d,s({ref:t},p))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"},243:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/backpacking_metagraph-50976049aa85a582ed0afc3e921187f2.png"},88:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return l}));var n=a(3),r=a(7),o=(a(0),a(194)),i={id:"backpacking-through-europe",title:"Backpacking through Europe",sidebar_label:"Backpacking through Europe"},s={unversionedId:"tutorials/backpacking-through-europe",id:"tutorials/backpacking-through-europe",isDocsHomePage:!1,title:"Backpacking through Europe",description:"This article is a part of a series intended to show users how to use Memgraph",source:"@site/docs/tutorials/backpacking-through-europe.md",slug:"/tutorials/backpacking-through-europe",permalink:"/memgraph/tutorials/backpacking-through-europe",editUrl:"https://github.com/memgraph/docs/tree/main/docs/tutorials/backpacking-through-europe.md",version:"current",sidebar_label:"Backpacking through Europe",sidebar:"memgraph",previous:{title:"Analyzing TED Talks",permalink:"/memgraph/tutorials/analyzing-ted-talks"},next:{title:"Exploring the European road network",permalink:"/memgraph/tutorials/exploring-the-european-road-network"}},c=[{value:"Introduction",id:"introduction",children:[]},{value:"Data model",id:"data-model",children:[]},{value:"Importing the Snapshot",id:"importing-the-snapshot",children:[]},{value:"Example Queries",id:"example-queries",children:[]}],p={toc:c};function l(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(o.a)("wrapper",Object(n.a)({},p,i,{components:t,mdxType:"MDXLayout"}),Object(o.a)("p",null,"This article is a part of a series intended to show users how to use Memgraph\non real-world data and, by doing so, retrieve some interesting and useful\ninformation."),Object(o.a)("p",null,"We highly recommend checking out the other articles from this series which\nare listed in our ",Object(o.a)("a",{parentName:"p",href:"/memgraph/tutorials/tutorials"},"tutorial overview section"),"."),Object(o.a)("h2",{id:"introduction"},"Introduction"),Object(o.a)("p",null,"Backpacking is a form of low-cost independent travel. It includes the use of\npublic transportation, inexpensive hostels and is often longer in duration\nthan conventional vacations.\nThis article explores the European Backpackers Index from 2018.\nThe dataset contains tourist prices and other data for 56 of the most popular\nEuropean cities. Here we showcase how Memgraph's graph traversal algorithms can\nbe used to make a real-time travelling recommendation system."),Object(o.a)("h2",{id:"data-model"},"Data model"),Object(o.a)("p",null,"The European Backpacker Index (2018) contains information for 56 cities from\n36 European countries.\nTwo cities are connected via the ",Object(o.a)("inlineCode",{parentName:"p"},":CloseTo")," edge if they are from the same\nor from the neighboring countries. Every edge has an ",Object(o.a)("inlineCode",{parentName:"p"},"eu_border")," property to\nindicate whether the EU border needs to be crossed to reach the other city.\nThe index lists the cheapest and most attractive hostel from each city.\nThe hostel name can be accessed via the ",Object(o.a)("inlineCode",{parentName:"p"},"cheapest_hostel")," parameter, and its\nwebsite is stored in ",Object(o.a)("inlineCode",{parentName:"p"},"hostel_url"),".\nThe city nodes also contain parameters for tourist information such as\n",Object(o.a)("inlineCode",{parentName:"p"},"local_currency"),", ",Object(o.a)("inlineCode",{parentName:"p"},"local_currency_code"),", and ",Object(o.a)("inlineCode",{parentName:"p"},"total_USD"),".\n",Object(o.a)("inlineCode",{parentName:"p"},"total_USD")," is the sum of the most common tourist expenses,\nsuch as ",Object(o.a)("inlineCode",{parentName:"p"},"cost_per_night_USD"),", ",Object(o.a)("inlineCode",{parentName:"p"},"attractions_USD"),", ",Object(o.a)("inlineCode",{parentName:"p"},"drinks_USD"),", ",Object(o.a)("inlineCode",{parentName:"p"},"meals_USD"),", and\n",Object(o.a)("inlineCode",{parentName:"p"},"transportation_USD"),".\nThe country nodes are connected with the ",Object(o.a)("inlineCode",{parentName:"p"},":Borders")," edge if they are\nneighboring countries. This edge also has the ",Object(o.a)("inlineCode",{parentName:"p"},"eu_border")," property.\nEvery city node is connected to its parent country node via the ",Object(o.a)("inlineCode",{parentName:"p"},":Inside"),"\nedge."),Object(o.a)("p",null,Object(o.a)("img",{src:a(243).default})),Object(o.a)("h2",{id:"importing-the-snapshot"},"Importing the Snapshot"),Object(o.a)("p",null,"We have prepared a database snapshot for this example, so the user can easily\nimport it when starting Memgraph using the ",Object(o.a)("inlineCode",{parentName:"p"},"--data-directory")," option."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-plaintext"},"sudo -u memgraph \\\n  /usr/lib/memgraph/memgraph --data-directory /usr/share/memgraph/examples/Backpacking \\\n    --storage-snapshot-interval-sec=0 --storage-wal-enabled=false \\\n    --storage-snapshot-on-exit=false --storage-properties-on-edges=true\n")),Object(o.a)("p",null,"When using Memgraph installed from DEB or RPM package, the currently running\nMemgraph server may need to be stopped before importing the example. The user\ncan do so using the following command:"),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-plaintext"},"systemctl stop memgraph\n")),Object(o.a)("p",null,"When using Docker, the example can be imported with the following command:"),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-plaintext"},"docker run -p 7687:7687 \\\n  -v mg_lib:/var/lib/memgraph -v mg_log:/var/log/memgraph -v mg_etc:/etc/memgraph \\\n  memgraph --data-directory /usr/share/memgraph/examples/Backpacking \\\n  --storage-snapshot-interval-sec=0 --storage-wal-enabled=false \\\n  --storage-snapshot-on-exit=false --storage-properties-on-edges=true\n")),Object(o.a)("p",null,"The user should note that any modifications of the database state will persist\nonly during this run of Memgraph."),Object(o.a)("h2",{id:"example-queries"},"Example Queries"),Object(o.a)("p",null,"1) Let's list the top 10 cities with the cheapest hostels by cost per night\nfrom the European Backpacker Index."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:City)\nRETURN n.name, n.cheapest_hostel, n.cost_per_night_USD, n.hostel_url\nORDER BY n.cost_per_night_USD LIMIT 10;\n")),Object(o.a)("p",null,"2) Say we want to visit Croatia. Which cities does Backpackers Index recommend?\nLet's sort them by total costs."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},'MATCH (c:City)-[:Inside]->(:Country {name: "Croatia"})\nRETURN c.name, c.cheapest_hostel, c.total_USD\nORDER BY c.total_USD;\n')),Object(o.a)("p",null,"3) What if we want to visit multiple cities in a single country and want to know\nwhich country has the most cities in the index?"),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},"MATCH (n:Country)<-[:Inside]-(m:City)\nRETURN n.name AS CountryName, COUNT(m) AS HostelCount\nORDER BY HostelCount DESC, CountryName LIMIT 10;\n")),Object(o.a)("p",null,"Now, let's start backpacking. This is where Memgraph's graph traversal\ncapabilities come into play."),Object(o.a)("p",null,"4) We're on a trip from Spain to Russia and want to cross the least amount of\nborders. This is a great job for the breadth-first search (BFS) algorithm."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},'MATCH p = (n:Country {name: "Spain"})\n          -[r:Borders * bfs]-\n          (m:Country {name: "Russia"})\nUNWIND (nodes(p)) AS rows\nRETURN rows.name;\n')),Object(o.a)("p",null,"5) What if we're interested in going from Bratislava to Madrid with the least\namount of stops? Also, we can't be bothered to switch currencies and want to\npay with Euro everywhere along the trip."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},'MATCH p = (:City {name: "Bratislava"})\n          -[:CloseTo * bfs (e, v | v.local_currency = "Euro")]-\n          (:City {name: "Madrid"})\nUNWIND (nodes(p)) AS rows\nRETURN rows.name;\n')),Object(o.a)("p",null,"Here we can see how to use the ",Object(o.a)("em",{parentName:"p"},"filter lambda")," to filter paths where the\nlocal currency in the city vertex ",Object(o.a)("inlineCode",{parentName:"p"},"v")," is the Euro.\n",Object(o.a)("inlineCode",{parentName:"p"},"nodes(p)")," returns the path as a list, and ",Object(o.a)("inlineCode",{parentName:"p"},"UNWIND")," unpacks the list\ninto individual rows."),Object(o.a)("p",null,"6) This time we're going from Brussels to Athens on a budget.\nWe're interested in the route with the cheapest stays.\nBut there's a problem, we've lost our passport!\nLuckily, we're a European Union citizen and can travel freely within the EU.\nLet's find the cheapest route from Brussels to Athens with no EU border crossings.\nThis is a good use case for the Dijkstra's shortest path algorithm."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},'MATCH p = (:City {name: "Brussels"})\n          -[:CloseTo * wShortest(e, v | v.cost_per_night_USD) total_cost (e, v | e.eu_border=FALSE)]-\n          (:City {name: "Athens"})\nWITH extract(city in nodes(p) | city.name) AS trip, total_cost\nRETURN trip, total_cost;\n')),Object(o.a)("p",null,"Here we used the ",Object(o.a)("em",{parentName:"p"},"weight lambda")," to specify the cost of expanding to the\nspecified vertex using the given edge (",Object(o.a)("inlineCode",{parentName:"p"},"v.cost_per_night_USD"),"), and the\n",Object(o.a)("em",{parentName:"p"},"total cost")," symbol to calculate the cost of the trip.\nThis can be done using an edge property like in the\n",Object(o.a)("a",{parentName:"p",href:"/memgraph/tutorials/exploring-the-european-road-network"},"Exploring the European Road Network"),"\ntutorial.\nHere we use ",Object(o.a)("inlineCode",{parentName:"p"},"cost_per_night")," property of the city vertex ",Object(o.a)("inlineCode",{parentName:"p"},"v")," as our weight.\nFinally, we use the ",Object(o.a)("em",{parentName:"p"},"filter lambda")," to only consider paths with no EU border\ncrossings. The ",Object(o.a)("inlineCode",{parentName:"p"},"extract")," function is used to only show the city names.\nTo get the full city information, we would simply return ",Object(o.a)("inlineCode",{parentName:"p"},"nodes(p)"),"."),Object(o.a)("p",null,"7) We're on a trip with our friends from Madrid to Belgrade, but want to visit\nVienna along the way. We want to party it up on the first part of our trip and\nare only interested in the cost of staying and drinks.\nAfter that, we plan on sightseeing and are interested in the cost of attractions\nfrom Vienna to Belgrade. What is our cheapest option?"),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},'MATCH p = (:City {name: "Madrid"})\n          -[:CloseTo * wShortest(e, v | v.cost_per_night_USD + v.drinks_USD) cost1]-\n          (:City {name: "Vienna"})\n          -[:CloseTo * wShortest(e, v | v.cost_per_night_USD + v.attractions_USD) cost2]-\n          (:City {name: "Belgrade"})\nWITH extract(city in nodes(p) | city.name) AS trip, cost1, cost2\nRETURN trip, cost1 + cost2 AS total_cost;\n')),Object(o.a)("p",null,"8) We're on a trip from Paris to Zagreb and want to visit at least 3 cities,\nbut no more than 5 (excluding the starting location ","\u2014"," Paris).\nLet's list our top 10 options sorted by the total trip cost and number of\ncities in the path."),Object(o.a)("pre",null,Object(o.a)("code",{parentName:"pre",className:"language-cypher"},'MATCH path = (n:City {name: "Paris"})-[:CloseTo *3..5]-(m:City {name: "Zagreb"}) \nWITH nodes(path) AS trip\nWITH extract(city in trip | [city, trip]) AS lst\nUNWIND lst AS rows\nWITH rows[0] AS city, extract(city in rows[1] | city.name) AS trip\nRETURN trip,\n       toInteger(sum(city.total_USD)) AS trip_cost_USD,\n       count(trip) AS city_count\nORDER BY trip_cost_USD, city_count DESC LIMIT 10;\n')),Object(o.a)("p",null,"Here we can see the usage of the variable length paths.\nBy using the ",Object(o.a)("inlineCode",{parentName:"p"},"*")," ",Object(o.a)("em",{parentName:"p"},"(asterisk)")," symbol, we can traverse from one node to another\nby following any number of connections.\nWe then use the extract function to get a list of (city, trip) tuples.\nThe city is used to calculate the total cost of the trip using the sum function.\nFinally, we sort our results by price first, and then by city count."),Object(o.a)("p",null,"To learn more about these algorithms, we suggest you check out their Wikipedia\npages:"),Object(o.a)("ul",null,Object(o.a)("li",{parentName:"ul"},Object(o.a)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"Breadth-first search")),Object(o.a)("li",{parentName:"ul"},Object(o.a)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"},"Dijkstra's algorithm"))))}l.isMDXComponent=!0}}]);